/* global DualChatbotConfig, wp */
// Frontend script for the Dual Chatbot Plugin.

(function(){
  // Prevent duplicate initialization if the script is injected twice
  if (window.__DualChatbotInitialized) {
    try { console.warn('Dual Chatbot already initialized; skipping duplicate init'); } catch(_) {}
    return;
  }
  window.__DualChatbotInitialized = true;
  // Small helper: is an element actually visible on screen?
  function isVisible(el){
    try {
      if (!el) return false;
      const s = getComputedStyle(el);
      if (s.display === 'none' || s.visibility === 'hidden' || Number(s.opacity) === 0) return false;
      const rect = el.getBoundingClientRect();
      return (rect.width > 0 && rect.height > 0);
    } catch(_e) { return false; }
  }
  function makeSessionId(){
    try { if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); } catch(e){}
    const s4=()=>Math.floor((1+Math.random())*0x10000).toString(16).substring(1);
    return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
  }
  function wpFetch(url, opts = {}) {
    opts.headers = opts.headers || {};
    opts.headers['X-WP-Nonce'] = DualChatbotConfig.nonce;
    return fetch(url, opts);
  }
  function showChatbotTrigger(){
    try {
      const wrapper = window.chatbotWrapper || document.getElementById('dual-chatbot-widget') || document.querySelector('#dual-chatbot-widget');
      if (wrapper) {
        // Remove inline/display-based hiding and common hidden classes
        wrapper.hidden = false;
        wrapper.style.removeProperty('display');
        wrapper.style.removeProperty('visibility');
        wrapper.classList.remove('hidden','is-hidden','d-none');
        // Fallback: force a visible display if still none
        if (getComputedStyle(wrapper).display === 'none') {
          wrapper.style.display = 'block';
        }

        const btn = wrapper.querySelector('#open-chatbot');
        if (btn) {
          btn.hidden = false;
          btn.style.removeProperty('display');
          btn.style.removeProperty('visibility');
          btn.classList.remove('hidden','is-hidden','d-none');
          if (getComputedStyle(btn).display === 'none') {
            btn.style.display = 'inline-flex';
          }
        }
        // Keep a reference for later
        window.chatbotWrapper = wrapper;
      }

      // Also ensure our own floating icon (if present) is visible
      const icon = document.querySelector('.dual-chatbot-icon');
      if (icon) {
        icon.hidden = false;
        icon.style.removeProperty('display');
        icon.classList.remove('hidden','is-hidden','d-none');
      }
    } catch (e) {
      // no-op: visibility best-effort only
    }
  }
  if (!window.DualChatbotConfig || (!DualChatbotConfig.faqEnabled && !DualChatbotConfig.advisorEnabled)) {
    console.warn('Kein Chatbot-Modus aktiviert!');
    // Trotzdem versuchen wir, einen evtl. vorhandenen Theme-Button sichtbar zu machen
    try { document.addEventListener('DOMContentLoaded', showChatbotTrigger); } catch(_) {}
    return;
  }
  const advisorMode = !!DualChatbotConfig.advisorEnabled;
  const faqMode = !!DualChatbotConfig.faqEnabled;
  const restBase = DualChatbotConfig.restUrl.replace(/\/$/, '');
  let currentSession = null;
  let advisorMinimized = false;
  let searchTimeoutId = null;
  // Prevent race conditions when loading history (e.g., double click)
  let historyLoadSeq = 0;
  let advisorFullscreenEl = null;
  function createElement(tag, classNames = '', children = [], id = null) {
    const el = document.createElement(tag);
    if (classNames) el.className = classNames;
    children.forEach(child => {
      if (typeof child === 'string') el.appendChild(document.createTextNode(child));
      else if (child instanceof Node) el.appendChild(child);
    });
    if (id) el.id = id;
    return el;
  }

  // Safe content renderer used by streaming; ensures it's always defined
  if (typeof setMessageContent !== 'function') {
    var setMessageContent = function(el, text) {
      try {
        const isContent = el && el.classList && el.classList.contains('dual-chatbot-message-content');
        if (isContent) {
          el.innerHTML = '';
          // Render plain text first (parser may replace later)
          el.textContent = text || '';
          return;
        }
        // Wrap into content container when not provided
        el.innerHTML = '';
        const content = document.createElement('div');
        content.className = 'dual-chatbot-message-content';
        content.textContent = text || '';
        el.appendChild(content);
      } catch (e) {
        try { el.textContent = text || ''; } catch(_) {}
      }
    };
  }

  // Safe fallback for action bar builder to avoid runtime errors during early stream
  if (typeof buildMsgActions !== 'function') {
    var buildMsgActions = function(msgRoot, sender, id, originalText) {
      try {
        if (!msgRoot) return;
        const existing = msgRoot.querySelector('.dual-msg-actions');
        if (!existing) {
          const bar = document.createElement('div');
          bar.className = 'dual-msg-actions';
          msgRoot.appendChild(bar);
        }
      } catch(e) { /* no-op fallback */ }
    };
  }
  function createHeader(title, { className = 'dual-chatbot-header', controlsLeft = false } = {}) {
    const header = createElement('div', className);
    const titleEl = createElement('span', 'dual-chatbot-header-title', [title]);
    const controls = createElement('div', 'dual-chatbot-controls');
    const closeBtn = createElement('button', 'dual-chatbot-close');
    closeBtn.type = 'button';
    closeBtn.setAttribute('aria-label', 'Fenster schlie√üen');
    controls.appendChild(closeBtn);
    if (controlsLeft) {
      header.appendChild(controls);
      header.appendChild(titleEl);
    } else {
      header.appendChild(titleEl);
      header.appendChild(controls);
    }
    return { header, titleEl, closeBtn };
  }

  // Append a message into the FAQ popup chat-area (left/right alignment via CSS)
  function appendMessage(sender, text) {
    try {
      const chatArea = document.querySelector('.dual-chatbot-chat-area');
      if (!chatArea) return;
      const msg = createElement('div', `dual-chatbot-message dual-chatbot-${sender}`);
      msg.textContent = text;
      chatArea.appendChild(msg);
      chatArea.scrollTop = chatArea.scrollHeight;
    } catch (e) {
      // no-op
    }
  }

  // Nachricht senden (Advisor ODER FAQ)
  async function sendMessage(text, containerEl) {
    if (!text) return;
    if (!advisorMode) {
      appendMessage('user', text);
    }
    const payload = {
      message: text,
      context: advisorMode ? 'advisor' : 'faq',
    };
    if (currentSession) payload.session_id = currentSession;
    try {
      const response = await wpFetch(`${restBase}/submit_message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload),
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.error || 'Fehler bei der Anfrage');
      currentSession = data.session_id;
      if (advisorMode && containerEl) {
        const msg = createElement('div', 'dual-chatbot-message dual-chatbot-bot');
        msg.textContent = data.response;
        containerEl.appendChild(msg);
        containerEl.scrollTop = containerEl.scrollHeight;
      } else {
        appendMessage('bot', data.response);
      }
    } catch (err) {
      if (advisorMode && containerEl) {
        const msg = createElement('div', 'dual-chatbot-message dual-chatbot-bot');
        msg.textContent = err.message;
        containerEl.appendChild(msg);
      } else {
        appendMessage('bot', err.message);
      }
    }
  }

  
  function scrollChatToBottom() {
    const chatArea = document.querySelector('.dual-chatbot-chat-area');
    if (chatArea) chatArea.scrollTop = chatArea.scrollHeight;
  }


// Nachricht mit Extras (z.B. Websuche im Advisor)
async function sendMessageWithExtras(text, containerEl, webSearch, options = {}) {
    if (!text) return;
    const payload = { message: text, context: 'advisor' };
    // Ensure a single session id from the very beginning (avoids duplicates)
    if (!currentSession) currentSession = makeSessionId();
    let streamSessionId = currentSession;
    payload.session_id = currentSession;
    // Generate idempotency id for this user message
    const clientMsgId = (options && options.clientMsgId)
      ? options.clientMsgId
      : ((window.crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(16)+Math.random().toString(16).slice(2,10)));
    payload.client_msg_id = clientMsgId;
    if (webSearch) payload.web_search = true;

    // Bot element handling: create placeholder unless replacing an existing bot message
    const replaceBotEl = options && options.replaceBotEl ? options.replaceBotEl : null;
    const replaceBotId = options && options.replaceBotId ? options.replaceBotId : null;
    if (replaceBotId || replaceBotEl) {
      // Prevent creating a new user row in history when regenerating
      payload.no_user_insert = true;
      payload.target_bot_id = replaceBotId || 0;
    }
    // Also allow callers to force no user insert (e.g. editing a user message without an existing bot reply)
    if (options && options.noUserInsert) {
      payload.no_user_insert = true;
    }
    let botEl, contentEl;
    if (replaceBotEl) {
      botEl = replaceBotEl;
      botEl.classList.add('is-typing');
      contentEl = botEl.querySelector('.dual-chatbot-message-content');
      if (!contentEl) { contentEl = createElement('div','dual-chatbot-message-content'); botEl.innerHTML=''; botEl.appendChild(contentEl); }
      contentEl.innerHTML = '';
    } else {
      botEl = createElement('div', 'dual-chatbot-message dual-chatbot-bot is-typing');
      contentEl = createElement('div','dual-chatbot-message-content');
      botEl.appendChild(contentEl);
      containerEl.appendChild(botEl);
    }
    const nearBottom = () => (containerEl.scrollTop + containerEl.clientHeight >= containerEl.scrollHeight - 40);
    const scrollIfNeeded = () => { if (nearBottom()) containerEl.scrollTop = containerEl.scrollHeight; };

    // Letter-by-letter typewriter similar to ChatGPT
    let full = '';
    let pending = '';
    let typeTimer = null;
    let sawDone = false;
    let lastDelta = '';
    const cps = 60; // characters per second (faster)
    const typeInterval = Math.max(10, Math.floor(1000 / cps));
    let finalized = false;
    const finalizeNow = async () => {
      if (finalized) return; finalized = true;
      if (typeTimer) { clearInterval(typeTimer); typeTimer = null; }
      if (pending && pending.length) { full += pending; pending = ''; }
      botEl.classList.remove('is-typing');
      const holder = botEl.querySelector('.dual-chatbot-message-content') || botEl;
      setMessageContent(holder, full);
      // Build immediately and ensure presence with re-checks
      const ensureActions = () => {
        try {
          const bar = botEl.querySelector('.dual-msg-actions');
          if (!bar) {
            // Ensure the bar sits under the latest assistant message in the container
            ensureAssistantActions(containerEl || botEl.parentElement, full);
            normalizeActionBars(containerEl || botEl.parentElement);
            return;
          }
          // If bar exists but has no buttons yet (fallback or race), rebuild
          if (!bar.querySelector('.dual-msg-btn')) {
            bar.remove();
            ensureAssistantActions(containerEl || botEl.parentElement, full);
            normalizeActionBars(containerEl || botEl.parentElement);
          }
        } catch(_) {}
      };
      ensureActions();
      requestAnimationFrame(() => { ensureActions(); scrollIfNeeded(); });
      setTimeout(() => { ensureActions(); scrollIfNeeded(); }, 120);
      setTimeout(() => { ensureActions(); scrollIfNeeded(); }, 400);
      setTimeout(() => { ensureActions(); scrollIfNeeded(); }, 800);
      actionsAdded = true;
      try {
        if (replaceBotId) {
          await wpFetch(`${restBase}/edit_bot_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: replaceBotId, session_id: streamSessionId || currentSession, content: full })});
        } else {
          await wpFetch(`${restBase}/append_history`, {
            method:'POST', headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify({ session_id: streamSessionId || currentSession, sender:'bot', context:'advisor', message: full, reply_to_client_msg_id: clientMsgId })
          });
        }
      } catch(_){}
      // After persisting, if we replaced an existing bot answer, ensure there is
      // only one bot message between this and the next user message.
      try {
        if (replaceBotEl || replaceBotId) {
          const container = containerEl || botEl.parentElement;
          const removeIfExtra = async (node) => {
            if (!node || node === botEl) return;
            if (node.classList && node.classList.contains('dual-chatbot-bot')) {
              const rid = node.dataset && node.dataset.id ? Number(node.dataset.id) : null;
              try { if (rid) { await wpFetch(`${restBase}/delete_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: rid, session_id: streamSessionId || currentSession })}); } } catch(_e){}
              try { node.remove(); } catch(_e){}
            }
          };
          // forward cleanup until next user
          let n = botEl.nextElementSibling;
          while (n && !n.classList.contains('dual-chatbot-user')) { const cur=n; n=n.nextElementSibling; await removeIfExtra(cur); }
          // backward cleanup until previous user
          let p = botEl.previousElementSibling;
          while (p && !p.classList.contains('dual-chatbot-user')) { const cur=p; p=p.previousElementSibling; await removeIfExtra(cur); }
          try { ensureAssistantActions(container); normalizeActionBars(container); } catch(_e){}
        }
      } catch(_e){}
    };
    const finishIfComplete = () => {
      if (sawDone && pending.length === 0 && !typeTimer) { finalizeNow(); }
    };
    const typeTick = () => {
      if (!pending.length) { clearInterval(typeTimer); typeTimer = null; finishIfComplete(); return; }
      const ch = pending[0];
      pending = pending.slice(1);
      full += ch;
      const holder = botEl.querySelector('.dual-chatbot-message-content') || botEl;
      holder.textContent = full;
      scrollIfNeeded();
    };
    let actionsAdded = false;
    const startTypewriter = () => { if (typeTimer) return; typeTimer = setInterval(typeTick, typeInterval); };
    const enqueueText = (t) => { if (!t) return; pending += t; startTypewriter(); };
    // Append deltas verbatim to preserve exact spacing/characters
    const enqueueDelta = (d) => {
      if (!d) return;
      enqueueText(d);
    };

    // Try streaming first
    try {
      const resp = await fetch(`${restBase}/stream_message`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-WP-Nonce': DualChatbotConfig.nonce },
        body: JSON.stringify(payload)
      });
      if (!resp.ok || !resp.body) throw new Error('Streaming nicht verf√ºgbar');
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        let idx;
        while ((idx = buffer.indexOf('\n')) >= 0) {
          // Keep whitespace inside payloads; only drop trailing CR
          let line = buffer.slice(0, idx);
          buffer = buffer.slice(idx + 1);
          if (line.endsWith('\r')) line = line.slice(0, -1);
          if (!line) continue;
          // Try NDJSON first (our backend)
          try {
            const obj = JSON.parse(line);
            if (obj.type === 'meta' && obj.session_id) { currentSession = obj.session_id; streamSessionId = obj.session_id; }
            if (obj.type === 'delta' && obj.content) {
              const d = String(obj.content);
              if (d && d.length > 0) {
                enqueueDelta(d);
                if(!actionsAdded){ buildMsgActions(botEl,'bot',null,''); actionsAdded=true; }
              }
            }
            if (obj.type === 'error') {
              botEl.textContent = obj.message || 'Fehler beim Streamen.';
            }
            if (obj.type === 'done') { sawDone = true; finalizeNow(); }
            continue;
          } catch(_) {
            // Maybe raw SSE from OpenAI proxied through (lines starting with 'data:')
            if (line.startsWith('data:')) {
              // Do not trim end: payload may be a JSON with whitespace tokens
              const payload = line.slice(5).replace(/^\s+/, '');
              if (payload === '[DONE]') { sawDone = true; finalizeNow(); continue; }
              try {
                const j = JSON.parse(payload);
                const d = (((j || {}).choices || [])[0] || {}).delta || {};
                if (typeof d.content === 'string' && d.content) {
                  const s = d.content;
                  enqueueDelta(s);
                  if(!actionsAdded){ buildMsgActions(botEl,'bot',null,''); actionsAdded=true; }
                }
              } catch(__) { /* ignore malformed chunks */ }
            }
          }
        }
      }
      // ensure scrolled at the end if user was following
      scrollIfNeeded();
      finishIfComplete();
      if (full) {
        // ensure any remaining buffered characters are included
        if (typeTimer) { clearInterval(typeTimer); typeTimer = null; }
        if (pending && pending.length) { full += pending; pending = ''; }
        const holder = botEl.querySelector('.dual-chatbot-message-content') || botEl;
        setMessageContent(holder, full);
        // Remove typing indicator and rebuild actions to ensure single bar sits beneath final content
        botEl.classList.remove('is-typing');
        buildMsgActions(botEl, 'bot', replaceBotId || null, full);
        // Persist edited or new bot message
        try {
          if (replaceBotId) {
            await wpFetch(`${restBase}/edit_bot_message`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: replaceBotId, session_id: streamSessionId || currentSession, content: full })
            });
          } else {
            await wpFetch(`${restBase}/append_history`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ session_id: streamSessionId || currentSession, sender: 'bot', context: 'advisor', message: full, reply_to_client_msg_id: clientMsgId })
            });
          }
        } catch(_){}
        try { ensureAssistantActions(containerEl || botEl.parentElement, full); normalizeActionBars(containerEl || botEl.parentElement); } catch(_){}
      }
    } catch (err) {
      // Fallback: non-streaming ‚Äì replace, do not append
      try {
        const response = await wpFetch(`${restBase}/submit_message`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await response.json();
        if (!response.ok) throw new Error(data.error || 'Fehler bei der Anfrage');
        currentSession = data.session_id;
        streamSessionId = data.session_id;
        // stop any typewriter and render once
        if (typeTimer) { clearInterval(typeTimer); typeTimer = null; }
        pending = '';
        full = data.response || '';
        const holder = botEl.querySelector('.dual-chatbot-message-content') || botEl;
        setMessageContent(holder, full);
        if(!actionsAdded){ buildMsgActions(botEl,'bot',replaceBotId || null,full); actionsAdded=true; }
        try {
          if (replaceBotId) {
            await wpFetch(`${restBase}/edit_bot_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: replaceBotId, session_id: streamSessionId || currentSession, content: full })});
          }
        } catch(_){}
        try { ensureAssistantActions(containerEl || botEl.parentElement, full); normalizeActionBars(containerEl || botEl.parentElement); } catch(_){}
        sawDone = true; finishIfComplete();
      } catch (e2) {
        botEl.classList.remove('is-typing');
        botEl.textContent = e2.message || 'Fehler';
      }
    }
  }

  // Initialisiere das richtige Widget je nach Modus
function initChatWidget(openDirect = false) {
  console.log('initChatWidget() wurde aufgerufen');
  // Avoid building twice (e.g., multiple event hooks)
  if (window.__DualChatbotWidgetMounted) {
    try { console.debug('Chat widget already mounted; skipping'); } catch(_) {}
    return;
  }
  if (advisorMode) {
      buildAdvisorWidget(openDirect);
      return;
    }
    if (faqMode) {
      buildFaqWidget(openDirect);
      return;
    }
    console.warn('Kein Chatbot-Modus aktiviert!');
  }

  // FAQ Widget
  function buildFaqWidget(openDirect = false) {
    let container = document.getElementById('dual-chatbot-container');
    if (container) {
      container.classList.add('dual-chatbot-container');
      container.innerHTML = '';
      // Force visible in case theme hid it
      container.hidden = false;
      container.style.removeProperty('display');
      container.style.removeProperty('visibility');
      container.classList.remove('hidden','is-hidden','d-none');
    } else {
      container = createElement('div', 'dual-chatbot-container', [], 'dual-chatbot-container');
    }
    document.body.appendChild(container);

    let icon = null;
    if (!openDirect) {
      icon = createElement('button', 'dual-chatbot-icon');
      icon.setAttribute('title', 'Chat');
      // ensure icon is visible (override theme display:none)
      icon.hidden = false;
      icon.style.removeProperty('display');
      icon.style.removeProperty('visibility');
      icon.classList.remove('hidden','is-hidden','d-none');
      container.appendChild(icon);
    }

    let open = openDirect;
    const popup = createElement('div', 'dual-chatbot-popup');
    popup.style.display = 'none';
    const { header, closeBtn } = createHeader((window.DualChatbotConfig && DualChatbotConfig.faqHeaderTitle) ? DualChatbotConfig.faqHeaderTitle : 'FAQ');
    closeBtn.addEventListener('click', () => {
      open = false;
      popup.style.display = 'none';
      if (icon) {
        icon.style.display = '';
      } else {
        container.remove();
      }
      showChatbotTrigger();
      window.widgetOpened = false;
    });

    // --- Chat-Area + Footer (Fixierung) ---
    const chatArea = createElement('div', 'dual-chatbot-chat-area');
    const footer = createElement('div', 'dual-chatbot-footer');
    footer.style.position = 'sticky';
    footer.style.bottom = '0';
    footer.style.background = 'inherit';
    footer.style.zIndex = '10';
      const input = createElement('textarea', 'dual-chatbot-input');
      input.setAttribute('rows', 1);
    if (window.DualChatbotConfig && DualChatbotConfig.inputPlaceholder) {
      input.placeholder = DualChatbotConfig.inputPlaceholder;
    }
    input.placeholder = 'Nachricht‚Ä¶';
    const sendBtn = createElement('button', 'dual-chatbot-send');
    const sendIconMask = createElement('span', 'dual-chatbot-icon-mask');
    sendBtn.appendChild(sendIconMask);
    sendBtn.type = 'button';

    // Wrap input + send in a single row so width can be centered like ChatGPT
    const inputRow = createElement('div', 'dual-chatbot-input-wrapper');
    inputRow.appendChild(input);
    inputRow.appendChild(sendBtn);
    footer.appendChild(inputRow);

      // Enter to send (FAQ input); Shift+Enter for newline
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          // avoid double send while already sending
          if (!sendBtn.dataset.sending) {
            sendBtn.click();
          }
        }
      });
      // Auto-resize up to ~220px then scroll internally
      (function(){
        const ta = input;
        const baseH = 44;
        const maxH  = 220; // match CSS
        const fit = () => {
          try {
            ta.style.height = baseH + 'px';
            const h = Math.min(ta.scrollHeight, maxH);
            ta.style.height = h + 'px';
            ta.style.overflowY = (ta.scrollHeight > maxH) ? 'auto' : 'hidden';
          } catch(_e){}
        };
        ['input','change'].forEach(ev => ta.addEventListener(ev, fit));
        requestAnimationFrame(fit);
      })();

      const triggerPress = () => {
        sendBtn.classList.add('is-sending');
        setTimeout(() => {
          if (!sendBtn.dataset.sending) sendBtn.classList.remove('is-sending');
        }, 120);
      };
      sendBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') triggerPress();
      });
      sendBtn.addEventListener('mousedown', triggerPress);

      // Aufbau
      popup.appendChild(header);
      popup.appendChild(chatArea);
      popup.appendChild(footer);
      container.appendChild(popup);

      if (openDirect) {
        popup.style.display = 'flex';
      }

      if (icon) {
        icon.addEventListener('click', () => {
          open = !open;
          popup.style.display = open ? 'flex' : 'none';
          icon.style.display = open ? 'none' : '';
        });
      }

      sendBtn.addEventListener('click', async () => {
        const text = input.value.trim();
        if (!text) return;
        input.value = '';
        // ensure any auto-grow/resize listeners update
        input.dispatchEvent(new Event('input'));
        try {
          sendBtn.classList.add('is-sending');
          sendBtn.dataset.sending = 'true';
          await sendMessage(text);
        } catch (err) {
          console.error(err);
        } finally {
          delete sendBtn.dataset.sending;
          sendBtn.classList.remove('is-sending');
        }
      });
  }

  // Advisor Widget
  function buildAdvisorWidget(openDirect = false) {
    let container = document.getElementById('dual-chatbot-container');
    if (container) {
      container.classList.add('dual-chatbot-container');
      container.innerHTML = '';
      // Force visible in case theme hid it
      container.hidden = false;
      container.style.removeProperty('display');
      container.style.removeProperty('visibility');
      container.classList.remove('hidden','is-hidden','d-none');
    } else {
      container = createElement('div', 'dual-chatbot-container', [], 'dual-chatbot-container');
    }
    document.body.appendChild(container);
    if (!openDirect) {
      const icon = createElement('button', 'dual-chatbot-icon');
      icon.setAttribute('title', 'Chat');
      if (window.DualChatbotConfig && DualChatbotConfig.bubbleIconUrl) {
        icon.style.backgroundImage = 'url(' + DualChatbotConfig.bubbleIconUrl + ')';
        icon.style.backgroundRepeat = 'no-repeat';
        icon.style.backgroundPosition = 'center';
        icon.style.backgroundSize = 'contain';
      }
      // Ensure icon visible regardless of theme CSS
      icon.hidden = false;
      icon.style.removeProperty('display');
      icon.style.removeProperty('visibility');
      icon.classList.remove('hidden','is-hidden','d-none');
      container.appendChild(icon);
      icon.addEventListener('click', () => {
        if (advisorMinimized && advisorFullscreenEl) {
          advisorFullscreenEl.style.display = 'flex';
          advisorMinimized = false;
        } else {
          initAdvisorView();
        }
      });
    } else {
      initAdvisorView();
    }
  }

  // Vollbild-Advisor-View
  async function initAdvisorView() {
    const existing = document.querySelector('.dual-chatbot-fullscreen');
    if (existing) existing.remove();
    const fs = createElement('div', 'dual-chatbot-fullscreen');
    advisorFullscreenEl = fs;

    // Sidebar mit Profil, Suche, neue Chats, Liste
    const sidebar = createElement('div', 'dual-chatbot-sidebar');
    if (DualChatbotConfig.profileUrl) {
      const profileLink = document.createElement('a');
      profileLink.className = 'dual-chatbot-profile';
      profileLink.href = DualChatbotConfig.profileUrl;
      profileLink.rel = 'noopener noreferrer';
      const label = DualChatbotConfig.userName && DualChatbotConfig.userName.trim() !== ''
        ? DualChatbotConfig.userName
        : (DualChatbotConfig.isLoggedIn ? 'Profil' : 'Anmelden');
      if (DualChatbotConfig.userAvatar) {
        const avatar = createElement('img');
        avatar.src = DualChatbotConfig.userAvatar;
        avatar.alt = label;
        profileLink.appendChild(avatar);
      }
      const nameSpan = createElement('span', '', [label]);
      profileLink.appendChild(nameSpan);
      sidebar.appendChild(profileLink);
    }
    const sbHeader = createElement('div', 'dual-chatbot-sidebar-header', ['Unterhaltungen']);
    // Sidebar collapse/expand toggle
    const sidebarToggle = createElement('button', 'dual-chatbot-sidebar-toggle');
    sidebarToggle.type = 'button';
    sidebarToggle.setAttribute('aria-label', 'Seitenleiste ein-/ausklappen');
    const searchWrapper = createElement('div', 'dual-chatbot-search-wrapper');
    const searchInput = createElement('input', 'dual-chatbot-search');
    searchInput.type = 'text';
    searchInput.placeholder = 'Suchen‚Ä¶';
    const newChatBtn = createElement('button', 'dual-chatbot-new-chat-btn', ['+ Neuer Chat']);
    const list = createElement('ul', 'dual-chatbot-sidebar-list');
    searchWrapper.appendChild(searchInput);
    // removed decorative search icon

    sidebar.appendChild(sbHeader);
    // Place toggle on the fullscreen container so it's visible even when sidebar is hidden
    fs.appendChild(sidebarToggle);
    sidebar.appendChild(searchWrapper);
    sidebar.appendChild(newChatBtn);
    sidebar.appendChild(list);

    // Main Chat Area
    const main = createElement('div', 'dual-chatbot-main');
    const mainChat = createElement('div', 'dual-chatbot-main-chat');
    const mainFooter = createElement('div', 'dual-chatbot-main-footer');
    const { header: mainHeader, titleEl: headerTitle, closeBtn } = createHeader((window.DualChatbotConfig && DualChatbotConfig.advisorHeaderTitle) ? DualChatbotConfig.advisorHeaderTitle : 'Berater-Chat', { className: 'dual-chatbot-main-header' });

    
    const micIcon = createElement('button', 'dual-chatbot-microphone');
    micIcon.type = 'button';
    micIcon.setAttribute('aria-label','Aufnahme starten');
    micIcon.setAttribute('aria-pressed','false');
    const micMask = createElement('span', 'dual-chatbot-icon-mask');
    micIcon.appendChild(micMask);

    // Aufnahme-Aktionsleiste (Vorschau + Abbrechen + √úbernehmen)
    const recordActions = createElement('div', 'dual-chatbot-record-actions');
    const recordPreview = createElement('span', 'dual-chatbot-record-preview');
    const cancelRecordBtn = createElement('button', 'dual-chatbot-record-btn dual-chatbot-record-cancel');
    cancelRecordBtn.type = 'button';
    cancelRecordBtn.setAttribute('aria-label','Aufnahme abbrechen');
    const acceptRecordBtn = createElement('button', 'dual-chatbot-record-btn dual-chatbot-record-accept');
    acceptRecordBtn.type = 'button';
    acceptRecordBtn.setAttribute('aria-label','Transkript √ºbernehmen');
    recordActions.appendChild(recordPreview);
    recordActions.appendChild(cancelRecordBtn);
    recordActions.appendChild(acceptRecordBtn);
    let searchToggle = null;
    let searchEnabled = false;
    if (DualChatbotConfig.webSearchEnabled) {
      const searchImg = document.createElement('img');
      searchImg.src = DualChatbotConfig.searchIconUrl;
      searchImg.alt = 'Suche';
      searchToggle = createElement('button', 'dual-chatbot-search-toggle', [searchImg]);
      searchToggle.type = 'button';
      searchToggle.title = 'Websuche';
      searchToggle.addEventListener('click', () => {
        searchEnabled = !searchEnabled;
        searchToggle.classList.toggle('active', searchEnabled);
      });
    }
    const inputWrapper = createElement('div', 'dual-chatbot-input-wrapper');
    const input = createElement('textarea', 'dual-chatbot-input');
    input.setAttribute('rows', 1);
    input.setAttribute('placeholder', 'Nachricht schreiben...');
    const sendBtn = createElement('button', 'dual-chatbot-send');
    const sendMask = createElement('span', 'dual-chatbot-icon-mask');
    sendBtn.appendChild(sendMask);
    sendBtn.type = 'button';

    const triggerPress = () => {
      sendBtn.classList.add('is-sending');
      setTimeout(() => {
        if (!sendBtn.dataset.sending) sendBtn.classList.remove('is-sending');
      }, 120);
    };
    sendBtn.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') triggerPress();
    });
    sendBtn.addEventListener('mousedown', triggerPress);

      input.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendBtn.click();
        }
      });
      // Auto-resize up to ~220px then scroll
      (function(){
        const ta = input;
        const baseH = 44;
        const maxH  = 220; // keep in sync with CSS
        const fit = () => {
          try {
            ta.style.height = baseH + 'px';
            const h = Math.min(ta.scrollHeight, maxH);
            ta.style.height = h + 'px';
            ta.style.overflowY = (ta.scrollHeight > maxH) ? 'auto' : 'hidden';
          } catch(_e){}
        };
        ['input','change'].forEach(ev => ta.addEventListener(ev, fit));
        requestAnimationFrame(fit);
      })();
inputWrapper.appendChild(input);
inputWrapper.appendChild(sendBtn);
inputWrapper.prepend(micIcon);
// Aktionsleiste direkt nach dem Mic einf√ºgen
inputWrapper.insertBefore(recordActions, micIcon.nextSibling);

    // ===== AUDIO-RECORDING + TIMER + STOP-BUTTON =====  
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let recordStartTime = null;
let recordTimerInterval = null;
let pendingTranscript = '';
let discardRecording = false; // wenn true -> onstop verwirft Aufzeichnung

// Timer-Element rechts neben dem Mic-Icon einf√ºgen
const timerEl = document.createElement('span');
timerEl.className = 'dual-chatbot-record-timer';
timerEl.style.marginLeft = '10px';
timerEl.style.fontSize = '0.95em';
timerEl.style.color = '#e04a2f';
timerEl.style.display = 'none';

// Timer hinter das Mic-Icon setzen
inputWrapper.insertBefore(timerEl, micIcon.nextSibling);

micIcon.addEventListener('click', async function () {
  // wenn aktuell Aufnahme l√§uft -> stoppen
  if (isRecording && mediaRecorder) {
    mediaRecorder.stop();
    stopRecordingUI();
    return;
  }

  // Browser-Unterst√ºtzung checken
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    alert('Audioaufnahme nicht unterst√ºtzt.');
    return;
  }

  try {
    // Mikrofon freigeben
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);

    // Aufnahme starten
    audioChunks = [];
    isRecording = true;
    discardRecording = false;
    pendingTranscript = '';
    micIcon.classList.add('recording');
    timerEl.style.display = '';
    showRecordActions('recording');
    recordStartTime = Date.now();
    updateTimer();
    recordTimerInterval = setInterval(updateTimer, 250);

    mediaRecorder.ondataavailable = (e) => {
      audioChunks.push(e.data);
    };

mediaRecorder.onstop = async () => {
      try { if (mediaRecorder && mediaRecorder.stream) { mediaRecorder.stream.getTracks().forEach(t => t.stop()); } } catch(e) {}
      stopRecordingUI();

      // Wenn abgebrochen, nichts weiter tun
      if (discardRecording) {
        audioChunks = [];
        hideRecordActions();
        discardRecording = false;
        return;
      }

      // Blob erstellen und zu Whisper senden
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

      recordPreview.textContent = 'Transkribiere ...';
      showRecordActions('processing');
      input.disabled = true;

      const formData = new FormData();
      formData.append('audio', audioBlob, 'recording.webm');
      formData.append('lang', 'de');

      try {
          const res = await wpFetch(DualChatbotConfig.whisperApiUrl, {
            method: 'POST',
            body: formData,
          });
          const data = await res.json().catch(()=>({}));
          if (res.ok && data && (data.transcript || data.text)) {
            pendingTranscript = (data.transcript || data.text || '').trim();
            recordPreview.textContent = pendingTranscript.length > 64 ? (pendingTranscript.slice(0, 64) + '...') : pendingTranscript;
            showRecordActions('review');
          } else {
            pendingTranscript = '';
            const msg = (data && (data.error || data.message)) ? (data.error || data.message) : 'Transkription fehlgeschlagen.';
            alert(msg);
            hideRecordActions();
          }
        } catch (err) {
          pendingTranscript = '';
          alert('Fehler beim Transkribieren: ' + err.message);
          hideRecordActions();
        } finally {
          input.disabled = false;
          input.focus();
        }};

    mediaRecorder.start();

    // Safety-Stop nach 30s
    setTimeout(() => {
      if (isRecording && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        stopRecordingUI();
      }
    }, 30000);

  } catch (e) {
    stopRecordingUI();
    try { if (mediaRecorder && mediaRecorder.stream) { mediaRecorder.stream.getTracks().forEach(t => t.stop()); } } catch(_e) {}
    alert('Audiozugriff verweigert: ' + e.message);
  }
});

// Aufnahme abbrechen (w√§hrend Aufnahme) oder verwerfen (nach Transkription)
cancelRecordBtn.addEventListener('click', () => {
  if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
    discardRecording = true;
    try { mediaRecorder.stop(); } catch (e) {}
    try { if (mediaRecorder && mediaRecorder.stream) { mediaRecorder.stream.getTracks().forEach(t => t.stop()); } } catch(_e) {}
    stopRecordingUI();
  } else {
    pendingTranscript = '';
    hideRecordActions();
  }
});

// Transkript √ºbernehmen
acceptRecordBtn.addEventListener('click', () => {
  if (!pendingTranscript) return;
  input.value = pendingTranscript;
  input.dispatchEvent(new Event('input'));
  pendingTranscript = '';
  hideRecordActions();
  input.focus();
});

function updateTimer() {
  if (!isRecording) {
    timerEl.textContent = '';
    timerEl.style.display = 'none';
    return;
  }
  const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
  const min = String(Math.floor(elapsed / 60)).padStart(2, '0');
  const sec = String(elapsed % 60).padStart(2, '0');
  timerEl.textContent = `${min}:${sec}`;
}

  function stopRecordingUI() {
  isRecording = false;
  micIcon.classList.remove('recording');
  clearInterval(recordTimerInterval);
  timerEl.textContent = '';
  timerEl.style.display = 'none';
}

// Anzeige der Aufnahme-Aktionen steuern
function showRecordActions(mode) {
  // mode: 'recording' | 'processing' | 'review'
  recordActions.style.display = 'inline-flex';
  recordActions.classList.toggle('is-recording', mode === 'recording');
  recordActions.classList.toggle('is-processing', mode === 'processing');
  recordActions.classList.toggle('is-review', mode === 'review');
  // Timer nur im Recording zeigen
  if (mode === 'recording') {
    timerEl.style.display = 'inline-block';
  } else {
    timerEl.style.display = 'none';
  }
  // Buttons schalten
  if (mode === 'recording' || mode === 'processing') {
    acceptRecordBtn.style.display = 'none';
    cancelRecordBtn.style.display = '';
    recordPreview.style.display = mode === 'processing' ? '' : 'none';
  } else if (mode === 'review') {
    acceptRecordBtn.style.display = '';
    cancelRecordBtn.style.display = '';
    recordPreview.style.display = '';
  }
}
function hideRecordActions() {
  recordActions.style.display = 'none';
  recordActions.classList.remove('is-recording','is-processing','is-review');
  recordPreview.textContent = '';
  acceptRecordBtn.style.display = 'none';
  cancelRecordBtn.style.display = 'none';
  timerEl.style.display = 'none';
}

// Senden-Button
  sendBtn.addEventListener('click', async () => {
  const text = input.value.trim();
  if (!text) return;
  input.value = '';
  input.dispatchEvent(new Event('input'));
  try {
    sendBtn.classList.add('is-sending');
    sendBtn.dataset.sending = 'true';
    // Pre-generate a client message id so DOM + server share the same id
    const plannedClientMsgId = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(16)+Math.random().toString(16).slice(2,10));
    appendMessageToContainer(mainChat, 'user', text, null, { clientMsgId: plannedClientMsgId });
    await sendMessageWithExtras(text, mainChat, searchEnabled, { clientMsgId: plannedClientMsgId });
    await loadSessions(searchInput.value.trim());
  } catch (err) {
    console.error(err);
  } finally {
    delete sendBtn.dataset.sending;
    sendBtn.classList.remove('is-sending');
  }
});

// Footer zusammensetzen (robust, falls mainFooter unerwartet fehlt)
const footerEl = (typeof mainFooter !== 'undefined' && mainFooter) ? mainFooter : createElement('div', 'dual-chatbot-main-footer');
if (searchToggle) footerEl.appendChild(searchToggle);
footerEl.appendChild(inputWrapper);

main.appendChild(mainHeader);
main.appendChild(mainChat);
main.appendChild(footerEl);
fs.appendChild(sidebar);
fs.appendChild(main);
document.body.appendChild(fs);
// Mark as mounted to prevent duplicate UI builds
window.__DualChatbotWidgetMounted = true;
// Lock page scroll so only the chatbot shows a scrollbar
document.documentElement.classList.add('dual-chatbot-modal-open');
document.body.classList.add('dual-chatbot-modal-open');
    (function () {
      const ta = document.querySelector('.dual-chatbot-input');
      if (!ta) return;

      const baseH = 44;   // muss zur CSS-H√∂he passen
      const maxH  = 160;  // muss zur CSS max-height passen

      const fit = () => {
        ta.style.height = baseH + 'px';
        const h = Math.min(ta.scrollHeight, maxH);
        ta.style.height = h + 'px';
        ta.style.overflowY = (ta.scrollHeight > maxH) ? 'auto' : 'hidden';
      };

      ['input','change'].forEach(ev => ta.addEventListener(ev, fit));
      // Initial
      requestAnimationFrame(fit);
    })();

    // Ensure initial auto-resize aligns with 220px cap even if earlier code used a lower cap
    (function(){
      try {
        const ta = document.querySelector('.dual-chatbot-input');
        if (!ta) return;
        const baseH = 44; // match CSS min-height
        const maxH  = 220; // match CSS max-height
        const fit = () => {
          ta.style.height = baseH + 'px';
          const h = Math.min(ta.scrollHeight, maxH);
          ta.style.height = h + 'px';
          ta.style.overflowY = (ta.scrollHeight > maxH) ? 'auto' : 'hidden';
        };
        requestAnimationFrame(fit);
      } catch(_e) {}
    })();

    // Sessions und Chatverlauf laden
    async function loadSessions(query = '') {
      try {
        const url = `${restBase}/search_sessions?query=${encodeURIComponent(query)}&context=advisor`;
        const res = await wpFetch(url, { method: 'GET' });
        const data = await res.json();
        list.innerHTML = '';
        if (data.sessions && data.sessions.length) {
          data.sessions.forEach(sess => {
            const title = sess.title || sess.session_id;
            const li = createElement('li', 'dual-chatbot-session-item');
            const titleSpan = createElement('span', 'dual-chatbot-session-title', [title]);
            li.appendChild(titleSpan);
            const delBtn = createElement('button', 'dual-chatbot-delete-btn', ['√ó']);
            const renameBtn = createElement('button', 'dual-chatbot-delete-btn', ['‚úé']);
            li.appendChild(renameBtn);
            li.appendChild(delBtn);
            li.dataset.sessionId = sess.session_id;
            // Selecting a session (click on text OR anywhere on the item)
            const openSession = () => {
              currentSession = sess.session_id;
              list.querySelectorAll('li').forEach(l => l.classList.remove('active'));
              li.classList.add('active');
              loadHistory(sess.session_id);
            };
            // Avoid double-trigger via bubbling: handle either target
            titleSpan.addEventListener('click', (e) => { e.stopPropagation(); openSession(); });
            li.addEventListener('click', openSession);
            // Double click to rename
            titleSpan.addEventListener('dblclick', () => {
              const currentText = titleSpan.textContent;
              const inputEdit = createElement('input', 'dual-chatbot-rename-input');
              inputEdit.type = 'text';
              inputEdit.value = currentText;
              li.replaceChild(inputEdit, titleSpan);
              inputEdit.focus();
              const finishRename = async () => {
                const newTitle = inputEdit.value.trim();
                if (newTitle && newTitle !== currentText) {
                  await wpFetch(`${restBase}/rename_session`, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ session_id: sess.session_id, title: newTitle })
                  });
                  titleSpan.textContent = newTitle;
                }
                li.replaceChild(titleSpan, inputEdit);
              };
              inputEdit.addEventListener('blur', finishRename);
              inputEdit.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  finishRename();
                }
              });
            });
            renameBtn.addEventListener('click', e => {
              e.stopPropagation();
              const currentText = titleSpan.textContent;
              const inputEdit = createElement('input', 'dual-chatbot-rename-input');
              inputEdit.type = 'text';
              inputEdit.value = currentText;
              li.replaceChild(inputEdit, titleSpan);
              inputEdit.focus();
              const finishRename = async () => {
                const newTitle = inputEdit.value.trim();
                if (newTitle && newTitle !== currentText) {
                  await wpFetch(`${restBase}/rename_session`, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ session_id: sess.session_id, title: newTitle })
                  });
                  titleSpan.textContent = newTitle;
                }
                li.replaceChild(titleSpan, inputEdit);
              };
              inputEdit.addEventListener('blur', finishRename);
              inputEdit.addEventListener('keydown', ev => {
                if (ev.key === 'Enter') {
                  ev.preventDefault();
                  finishRename();
                }
              });
            });
            delBtn.addEventListener('click', async e => {
              e.stopPropagation();
              if (confirm('Gespr√§ch l√∂schen?')) {
                await wpFetch(`${restBase}/delete_session`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ session_id: sess.session_id })
                });
                if (currentSession === sess.session_id) {
                  currentSession = null;
                  mainChat.innerHTML = '';
                }
                await loadSessions(searchInput.value.trim());
              }
            });
            list.appendChild(li);
          });
        }
      } catch (err) {
        console.error(err);
      }
    }

    async function loadHistory(sessionId) {
      const seq = ++historyLoadSeq;
      try {
        const res = await wpFetch(`${restBase}/get_history?session_id=${encodeURIComponent(sessionId)}`, {
          method: 'GET'
        });
        const data = await res.json();
        // Only the latest invocation may render
        if (seq !== historyLoadSeq) return;
        mainChat.innerHTML = '';
        if (data.history) {
          const seenUser = new Set();
          const seenBot = new Set();
          let lastUserText = null;
          let lastBotText = null;
          data.history.forEach(item => {
            const id = item.id || null;
            const sender = item.sender;
            const cmid = item.client_msg_id || null;
            const rid = item.reply_to_client_msg_id || null;
            const txt = (item.message_content || '').trim();
            if (sender === 'user' && cmid) {
              if (seenUser.has(cmid)) return; seenUser.add(cmid);
            }
            if (sender === 'bot' && rid) {
              if (seenBot.has(rid)) return; seenBot.add(rid);
            }
            // Fallback dedupe by adjacent identical text (covers legacy rows without IDs)
            if (sender === 'user') {
              if (cmid == null && lastUserText !== null && txt === lastUserText) return;
              lastUserText = txt;
            } else {
              if (rid == null && lastBotText !== null && txt === lastBotText) return;
              lastBotText = txt;
            }
            appendMessageToContainer(mainChat, sender, item.message_content, id, { clientMsgId: cmid, replyToClientMsgId: rid });
          });
          // After rendering the full history, normalize bars once
          try { ensureAssistantActions(mainChat); normalizeActionBars(mainChat); } catch(_){}
        }
        mainChat.scrollTop = mainChat.scrollHeight;
      } catch (err) {
        console.error(err);
      }
    }

  // --- Message rendering helpers (actions, code copy) ---
  function detectLanguage(snippet) {
    const s = snippet.trim();
    if (/^\{[\s\S]*\}$/.test(s) || /"\w+"\s*:/.test(s)) return 'json';
    if (/^<\/?[a-z!]/i.test(s)) return 'html';
    if (/function\s+|=>|const\s+|let\s+|console\./.test(s)) return 'javascript';
    if (/def\s+\w+\(|import\s+\w+|print\(/.test(s)) return 'python';
    if (/^\$|\becho\b|\bgrep\b|\bcat\b/.test(s)) return 'bash';
    if (/\$[a-z_]+\s*=|->|echo\s+|function\s*\(/i.test(s)) return 'php';
    if (/^\.|\#[^{]+\{|\bcolor:|display:/.test(s)) return 'css';
    return 'text';
  }
  function setMessageContent(el, text) {
    // Render rich message content into an existing container. If the provided
    // element is already the content container, render directly into it to
    // avoid nested wrappers (which could visually push action bars above).
    let content;
    if (el.classList && el.classList.contains('dual-chatbot-message-content')) {
      el.innerHTML = '';
      content = el;
    } else {
      el.innerHTML = '';
      content = createElement('div', 'dual-chatbot-message-content');
      el.appendChild(content);
    }
    // parse triple backticks
    const regex = /```(\w+)?\n([\s\S]*?)```/g;
    let lastIndex = 0; let m;
    while ((m = regex.exec(text)) !== null) {
      const before = text.slice(lastIndex, m.index);
      if (before) content.appendChild(document.createTextNode(before));
      const lang = (m[1] || detectLanguage(m[2])).toLowerCase();
      const pre = createElement('pre', 'dual-codeblock');
      const code = createElement('code', `lang-${lang}`);
      code.textContent = m[2];
      const copyBtn = createElement('button', 'dual-code-copy icon-copy');
      copyBtn.setAttribute('aria-label','Code kopieren');
      copyBtn.setAttribute('data-tip','Kopieren');
      copyBtn.type = 'button';
      copyBtn.addEventListener('click', async () => {
        try { await navigator.clipboard.writeText(m[2]); copyBtn.setAttribute('data-tip','Kopiert'); setTimeout(()=>copyBtn.setAttribute('data-tip','Kopieren'), 1200);} catch(_e) {}
      });
      const label = createElement('span', 'dual-code-lang', [lang]);
      pre.appendChild(copyBtn);
      pre.appendChild(label);
      pre.appendChild(code);
      content.appendChild(pre);
      lastIndex = regex.lastIndex;
    }
    const tail = text.slice(lastIndex);
    if (tail) content.appendChild(document.createTextNode(tail));
    // if el was not the content container, it already has the child appended
  }
  function buildMsgActions(msgRoot, sender, id, originalText) {
    // Idempotent: ensure a single persistent action bar per message
    let bar = msgRoot.querySelector('.dual-msg-actions');
    const allBars = msgRoot.querySelectorAll('.dual-msg-actions');
    if (allBars.length > 1) {
      for (let i = 1; i < allBars.length; i++) allBars[i].remove();
      bar = allBars[0];
    }
    if (bar && bar.dataset && bar.dataset.initialized === '1') {
      if (bar !== msgRoot.lastElementChild) msgRoot.appendChild(bar);
      return;
    }
    if (!bar) bar = createElement('div', 'dual-msg-actions');
    const btnCopy = createElement('button', 'dual-msg-btn msg-copy icon-copy');
    btnCopy.setAttribute('aria-label','Kopieren');
    btnCopy.setAttribute('data-tip','Kopieren');
    btnCopy.addEventListener('click', async () => {
      const txt = originalText || msgRoot.querySelector('.dual-chatbot-message-content')?.innerText || msgRoot.innerText;
      try { await navigator.clipboard.writeText(txt); btnCopy.setAttribute('data-tip','Kopiert'); setTimeout(()=>btnCopy.setAttribute('data-tip','Kopieren'), 1200);} catch(_e){}
    });
    // reset or initialize content once
    bar.innerHTML = '';
    bar.appendChild(btnCopy);
    if (sender === 'bot') {
      const btnRegen = createElement('button', 'dual-msg-btn msg-regen icon-regen');
      btnRegen.setAttribute('aria-label','Neu generieren');
      btnRegen.setAttribute('data-tip','Neu generieren');
      btnRegen.addEventListener('click', () => {
        // find previous user message text in container
        let prev = msgRoot.previousElementSibling;
        while (prev && !prev.classList.contains('dual-chatbot-user')) prev = prev.previousElementSibling;
        const prompt = prev ? (prev.querySelector('.dual-chatbot-message-content')?.innerText || prev.innerText) : '';
        if (prompt) {
          const botId = id || (msgRoot.dataset && msgRoot.dataset.id ? Number(msgRoot.dataset.id) : null);
          sendMessageWithExtras(prompt, msgRoot.parentElement, false, { replaceBotEl: msgRoot, replaceBotId: botId });
        }
      });
      bar.appendChild(btnRegen);
      const up = createElement('button', 'dual-msg-btn msg-up icon-up');
      up.setAttribute('aria-label','Hilfreich'); up.setAttribute('data-tip','Hilfreich');
      const down = createElement('button', 'dual-msg-btn msg-down icon-down');
      down.setAttribute('aria-label','Nicht hilfreich'); down.setAttribute('data-tip','Nicht hilfreich');
      const react = async (r) => {
        let feedback = '';
        if (r === 'down') feedback = window.prompt('Was war nicht hilfreich? (optional)') || '';
        try { await wpFetch(`${restBase}/react_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: id || 0, reaction: r, feedback })}); } catch(_e) {}
      };
      up.addEventListener('click', ()=>react('up'));
      down.addEventListener('click', ()=>react('down'));
      bar.appendChild(up); bar.appendChild(down);
      // Delete bot message (DOM + history)
      const btnDelBot = createElement('button', 'dual-msg-btn msg-del icon-del');
      btnDelBot.setAttribute('aria-label','L√∂schen'); btnDelBot.setAttribute('data-tip','L√∂schen');
      btnDelBot.addEventListener('click', async () => {
        const parent = msgRoot.parentElement;
        if (!confirm('Antwort l√∂schen?')) return;
        const rowId = id || (msgRoot && msgRoot.dataset && msgRoot.dataset.id ? Number(msgRoot.dataset.id) : null);
        try { if (rowId) { await wpFetch(`${restBase}/delete_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: rowId, session_id: currentSession })}); } } catch(_e) {}
        try { msgRoot.querySelectorAll('.dual-msg-actions').forEach(b => b.remove()); msgRoot.remove(); } catch(_e) {}
        try { ensureAssistantActions(parent); normalizeActionBars(parent); } catch(_){}
      });
      bar.appendChild(btnDelBot);
    } else {
      const btnEdit = createElement('button', 'dual-msg-btn msg-edit icon-edit');
      btnEdit.setAttribute('aria-label','Bearbeiten'); btnEdit.setAttribute('data-tip','Bearbeiten');
      const btnDel = createElement('button', 'dual-msg-btn msg-del icon-del');
      btnDel.setAttribute('aria-label','L√∂schen'); btnDel.setAttribute('data-tip','L√∂schen');
      btnEdit.addEventListener('click', () => {
        const bubble = msgRoot.querySelector('.dual-chatbot-bubble');
        const content = msgRoot.querySelector('.dual-chatbot-message-content');
        const old = content ? content.innerText : originalText || '';
        // Build inline editor styled like input pill
        const wrap = createElement('div', 'dual-chatbot-input-wrapper dual-inline-edit');
        const ta = createElement('textarea', 'dual-chatbot-input');
        ta.setAttribute('rows', 1);
        ta.value = old;
        const cancelBtn = createElement('button', 'dual-chatbot-cancel'); cancelBtn.type = 'button'; cancelBtn.textContent = 'Abbrechen';
        const saveBtn = createElement('button', 'dual-chatbot-send'); saveBtn.type = 'button';
        const mask = createElement('span', 'dual-chatbot-icon-mask'); saveBtn.appendChild(mask);
        wrap.appendChild(ta);
        wrap.appendChild(cancelBtn);
        wrap.appendChild(saveBtn);
        if (bubble) bubble.replaceWith(wrap); else if (content) content.replaceWith(wrap);
        // Auto-grow the textarea so full text stays visible
          const baseH = 44;
          const maxH = 220;
          const fit = () => {
            try {
              ta.style.height = baseH + 'px';
              const h = Math.min(ta.scrollHeight, maxH);
              ta.style.height = h + 'px';
              ta.style.overflowY = (ta.scrollHeight > maxH) ? 'auto' : 'hidden';
            } catch(_e){}
          };
        ['input','change'].forEach(ev => ta.addEventListener(ev, fit));
        requestAnimationFrame(fit);
        setTimeout(fit, 60);
        ta.focus();

        const restoreView = (text) => {
          const newBubble = createElement('div','dual-chatbot-bubble');
          const cont = createElement('div','dual-chatbot-message-content'); cont.textContent = text;
          newBubble.appendChild(cont);
          wrap.replaceWith(newBubble);
          buildMsgActions(msgRoot, 'user', id, text);
        };

        const doSave = async () => {
          const val = ta.value.trim();
          if (!val || val === old) { restoreView(old); return; }
          try { await wpFetch(`${restBase}/edit_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id, session_id: currentSession, content: val })}); } catch(_e) {}
          restoreView(val);
          // Replace the following bot message instead of adding a new one
          let next = msgRoot.nextElementSibling;
          while (next && !next.classList.contains('dual-chatbot-bot') && !next.classList.contains('dual-chatbot-user')) next = next.nextElementSibling;
          if (next && next.classList.contains('dual-chatbot-bot')) {
            const botId = next.dataset && next.dataset.id ? Number(next.dataset.id) : null;
            // Remove any further bot messages until the next user message (clean duplicates)
            let rem = next.nextElementSibling;
            while (rem && !rem.classList.contains('dual-chatbot-user')) {
              if (rem.classList.contains('dual-chatbot-bot')) {
                try { const rid = rem.dataset && rem.dataset.id ? Number(rem.dataset.id) : null; if (rid) await wpFetch(`${restBase}/delete_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: rid, session_id: currentSession })}); } catch(_){}
                rem.remove();
              }
              rem = rem.nextElementSibling;
            }
            sendMessageWithExtras(val, msgRoot.parentElement, false, { replaceBotEl: next, replaceBotId: botId });
          } else {
            // If no bot answer exists yet, request one freshly but do not create a duplicate user row
            const existingCmid = (msgRoot && msgRoot.dataset && msgRoot.dataset.clientMsgId) ? msgRoot.dataset.clientMsgId : undefined;
            sendMessageWithExtras(val, msgRoot.parentElement, false, { noUserInsert: true, clientMsgId: existingCmid });
          }
        };
        const doCancel = () => restoreView(old);

        saveBtn.addEventListener('click', doSave);
        cancelBtn.addEventListener('click', doCancel);
        ta.addEventListener('keydown', e=>{
          if (e.key==='Enter' && !e.shiftKey) { e.preventDefault(); doSave(); }
          if (e.key==='Escape') { e.preventDefault(); doCancel(); }
        });
      });
      btnDel.addEventListener('click', async () => {
        if (!id) { msgRoot.remove(); return; }
        if (!confirm('Nachricht l√∂schen?')) return;
        try { await wpFetch(`${restBase}/delete_message`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id, session_id: currentSession })}); msgRoot.remove(); } catch(_e) {}
      });
      bar.appendChild(btnEdit); bar.appendChild(btnDel);
    }
    if (bar !== msgRoot.lastElementChild) msgRoot.appendChild(bar);
    if (bar.dataset) bar.dataset.initialized = '1';
  }
  // Attach a single action bar under assistant messages in an idempotent way
  function ensureAssistantActions(containerEl, contentText = '') {
    try {
      const bots = containerEl.querySelectorAll('.dual-chatbot-message.dual-chatbot-bot');
      if (!bots || !bots.length) return;
      const last = bots[bots.length - 1];
      if (last.classList && last.classList.contains('is-typing')) return;
      // Only the latest assistant message should show actions; remove from older ones
      bots.forEach((msg, idx) => {
        if (msg.classList && msg.classList.contains('is-typing')) return; // skip typing ones
        if (msg !== last) {
          msg.querySelectorAll('.dual-msg-actions').forEach(el => el.remove());
          return;
        }
        const existingBars = msg.querySelectorAll('.dual-msg-actions');
        if (existingBars.length > 1) {
          // Keep only the last bar
          for (let i = 0; i < existingBars.length - 1; i++) existingBars[i].remove();
        }
        let bar = msg.querySelector('.dual-msg-actions');
        if (!bar) {
          const text = msg.querySelector('.dual-chatbot-message-content')?.innerText || msg.innerText || contentText;
          buildMsgActions(msg, 'bot', null, text);
          bar = msg.querySelector('.dual-msg-actions');
        }
        if (bar && bar !== msg.lastElementChild) msg.appendChild(bar);
        if (bar && bar.dataset) bar.dataset.initialized = '1';
      });
    } catch (e) { /* no-op */ }
  }

  // Stronger normalization: ensure at most one bar per message across container
  function normalizeActionBars(containerEl) {
    try {
      const msgs = containerEl.querySelectorAll('.dual-chatbot-message');
      msgs.forEach(msg => {
        const bars = msg.querySelectorAll('.dual-msg-actions');
        if (bars.length > 1) {
          for (let i = 0; i < bars.length - 1; i++) bars[i].remove();
        }
        let bar = msg.querySelector('.dual-msg-actions');
        if (bar) {
          if (bar !== msg.lastElementChild) msg.appendChild(bar);
          if (bar.dataset) bar.dataset.initialized = '1';
          return;
        }
        // If missing, create lazily
        const text = msg.querySelector('.dual-chatbot-message-content')?.innerText || msg.innerText || '';
        if (msg.classList.contains('dual-chatbot-bot')) {
          try { buildMsgActions(msg, 'bot', null, text); } catch(_) {}
        }
      });
        } catch(_){}
      }

function appendMessageToContainer(containerEl, sender, text, id=null, opts={}) {
        // Idempotent rendering: skip if message already exists by id/client_msg_id/reply_to_client_msg_id
        try {
          if (id && containerEl.querySelector(`[data-id="${CSS.escape(String(id))}"]`)) {
            return; // already present
          }
          if (opts && opts.clientMsgId) {
            const cm = String(opts.clientMsgId);
            if (containerEl.querySelector(`[data-client-msg-id="${CSS.escape(cm)}"]`)) return;
          }
          if (opts && opts.replyToClientMsgId) {
            const rid = String(opts.replyToClientMsgId);
            if (containerEl.querySelector(`[data-reply-to-client-msg-id="${CSS.escape(rid)}"]`)) return;
          }
        } catch(_e) {}
        const msgEl = createElement('div', `dual-chatbot-message dual-chatbot-${sender}`);
        if (id) msgEl.dataset.id = String(id);
        if (opts && opts.clientMsgId) msgEl.dataset.clientMsgId = String(opts.clientMsgId);
        if (opts && opts.replyToClientMsgId) msgEl.dataset.replyToClientMsgId = String(opts.replyToClientMsgId);
      const contentHolder = createElement('div','dual-chatbot-message-content');
      if (sender === 'bot') {
        setMessageContent(contentHolder, text);
        msgEl.appendChild(contentHolder);
        // Do not attach actions here for history; will be added to latest only
      } else {
        // Wrap user content in bubble; no action bar for user messages
        const bubble = createElement('div','dual-chatbot-bubble');
        contentHolder.textContent = text;
        bubble.appendChild(contentHolder);
        msgEl.appendChild(bubble);
        // Intentionally no action bar for user messages
      }
      containerEl.appendChild(msgEl);
      if (sender === 'bot') { ensureAssistantActions(containerEl, text); }
      // Guarantee a single bar per message; for bots only on the latest
      normalizeActionBars(containerEl);
      containerEl.scrollTop = containerEl.scrollHeight;
    }

    newChatBtn.addEventListener('click', () => {
      currentSession = null;
      mainChat.innerHTML = '';
      list.querySelectorAll('li').forEach(l => l.classList.remove('active'));
    });

    searchInput.addEventListener('input', () => {
      clearTimeout(searchTimeoutId);
      searchTimeoutId = setTimeout(() => {
        loadSessions(searchInput.value.trim());
      }, 300);
    });


    // Observe the main chat for new assistant messages and attach actions
      try {
        const actionsObserver = new MutationObserver((mutations) => {
          try { ensureAssistantActions(mainChat); normalizeActionBars(mainChat); } catch(_) {}
        });
        // Persist observer on the fullscreen container so we can disconnect on close
        fs.__actionsObserver = actionsObserver;
        actionsObserver.observe(mainChat, { childList: true, subtree: true });
        // initial normalize after history render
        requestAnimationFrame(() => { try { ensureAssistantActions(mainChat); normalizeActionBars(mainChat); } catch(_) {} });
        setTimeout(() => { try { ensureAssistantActions(mainChat); normalizeActionBars(mainChat); } catch(_) {} }, 120);
      } catch(_){}

    // Sidebar toggle and close button (advisor)
    sidebarToggle.addEventListener('click', () => {
      const minimized = fs.classList.toggle('dual-chatbot-minimized');
      sidebarToggle.setAttribute('aria-label', minimized ? 'Seitenleiste ausklappen' : 'Seitenleiste einklappen');
    });
      closeBtn.addEventListener('click', () => {
        try { if (searchTimeoutId) { clearTimeout(searchTimeoutId); searchTimeoutId = null; } } catch(_) {}
        try { if (fs.__actionsObserver) { fs.__actionsObserver.disconnect(); delete fs.__actionsObserver; } } catch(_) {}
        fs.remove();
        advisorMinimized = false;
        // restore page scroll
        document.documentElement.classList.remove('dual-chatbot-modal-open');
        document.body.classList.remove('dual-chatbot-modal-open');
        // If we opened directly (no bubble icon), remove the empty container as well
        const cont = document.getElementById('dual-chatbot-container');
        if (cont && !cont.querySelector('.dual-chatbot-icon')) {
          cont.remove();
        }
        showChatbotTrigger();
        window.widgetOpened = false;
        window.__DualChatbotWidgetMounted = false;
      });
    loadSessions();
  }

    if (!window.__DualChatbotBootBound) {
      window.__DualChatbotBootBound = true;
      document.addEventListener('DOMContentLoaded', () => {
      if ('visualViewport' in window) { visualViewport.addEventListener('resize', scrollChatToBottom); } else { window.addEventListener('resize', scrollChatToBottom); }
      console.log('DOMContentLoaded Event');
      const footerBtn = document.getElementById('open-chatbot');
      if (footerBtn) {
        footerBtn.classList.add('dual-chatbot-open');
      // Ensure wrapper/button are visible on load in case theme hides them
      const wrapper = footerBtn.closest('#dual-chatbot-widget');
      if (wrapper) {
        wrapper.hidden = false;
        wrapper.style.removeProperty('display');
        wrapper.classList.remove('hidden','is-hidden','d-none');
        window.chatbotWrapper = wrapper;
      }
      footerBtn.hidden = false;
      footerBtn.style.removeProperty('display');
      footerBtn.classList.remove('hidden','is-hidden','d-none');

        window.widgetOpened = false;
        // Avoid binding click twice
        if (!footerBtn.__dualClickBound) {
          footerBtn.__dualClickBound = true;
          footerBtn.addEventListener('click', function() {
            if (!window.widgetOpened && !document.querySelector('.dual-chatbot-fullscreen') && !document.querySelector('.dual-chatbot-popup')) {
              initChatWidget(true);
              window.widgetOpened = true;
              const wrapper = footerBtn.closest('#dual-chatbot-widget');
              if (wrapper) {
                wrapper.style.display = 'none';
                window.chatbotWrapper = wrapper;
              }
            }
          });
        }
        // Fallback: If theme/CSS still hides the trigger, spawn our floating icon
        setTimeout(() => {
          try {
            if (!isVisible(footerBtn) && !document.querySelector('.dual-chatbot-icon') && !document.querySelector('.dual-chatbot-fullscreen') && !document.querySelector('.dual-chatbot-popup')) {
              initChatWidget(false); // creates floating bubble icon
            }
          } catch(_){}
        }, 300);
      } else {
        initChatWidget();
      }
      });
    }

})();




